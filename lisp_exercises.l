(defun my_length(l)
	(cond ((null l) 0)
		(t (+ 1 (my_length (cdr l))))))

(defun my_memq(A L)
	(cond ( (null L) nil)
		  ( (eq A (car L)) (cons A (cdr L)))
		  (t (my_memq A (cdr L)))
	))

(defun my_append(L1 L2)
	(cond ( (null L1) L2)
		  ( (null L2) L1)
		  (t (cons (car L1) (my_append (cdr L1) L2)))
	))

(defun my_attach(O L)
	(cond ( (null L) (cons O nil))
		  (t (cons (car L) (my_attach O (cdr L))))
	))

(defun my_assoc(A L)
	(cond ( (null L) nil)
		  ( (eq A (car (car L))) (car L))
		  ;( (eq A (car (car L))) (cons A (cdr (car L))))
		  ;(	(eq A (caar L)) (cons A (cdar L)))
		  (t (my_assoc A (cdr L)))
	))

(defun freq(A L)
	(cond ( (null L) 0)
		  ( (eq A (car L)) (+ 1 (freq A (cdr L))))
		  ( (listp (car L)) (+ (freq A (car L)) (freq A (cdr L))))
		  (t (freq A (cdr L)))
	))

;(defun mapping(L val)
;	(cond ( (null L) L)
;		  ( (< (caar L) val) (cons (cadar L) (mapping (cdr L) val)))
;		  (t (mapping (cdr L) val))
;	))

(defun mapping(L val)
	(cond ( (null L) nil)
		  ( (< (car (car L)) val) (cons (car (cdr (car L))) (mapping (cdr L) val)))
		  ;( (< (caar L) val) (cons (cadar L) (mapping (cdr L) val)))
		  (t (mapping (cdr L) val))
	))

(defun last_helper(A L R)
	(cond ( (null L) R)
		  ( (eq A (car L)) (last_helper A (cdr L) L))
		  (t (last_helper A (cdr L) R))))

(defun my_last(A L)
	(last_helper A L nil))

;(defun my_last(A L)
;	(cond ( (null (my_memq A L)) nil)
;		  ( (null (my_memq A (cdr L))) (my_memq A L))
;		  (t (my_last A (cdr L)))
;	))

(defun my_reverse(L)
	(cond ( (null L) nil)
		  (t (my_append (my_reverse (cdr L)) (cons (car L) '())))
	))

;(defun is_pattern?(pat str)
;	(cond ( (null pat) nil)
;		  ( 

;(defun is_pattern?(pat str)
;	(cond ( (null (car pat)) cons str '())
;		  ( (null (car str)) nil)
;		  ( (eq (car pat) (car str))
;			(cond ( (eq (is_pattern? (cdr pat) (cdr str)) (cdr str)) (const str '())))
;				  ;(t (is_pattern? pat (cdr str))))
;		  (t (is_pattern? pat (cdr str)))))

;(defun is_pattern?(pat str)
;	(cond ( (null pat) str)
;		  ( (eq (car pat) (car str)) (cons (car str) (is_pattern? (cdr pat) (cdr str)))
;			(cond ( (null (cdr pat)) (my_append pat (cdr str)))
;				  (t (is_pattern? (cdr pat) (cdr str)))))
;		  ;( (eq (car pat) (car str)) (cons (car pat) (cons (is_pattern? (cdr pat) (cdr str)) (cdr str))))
;		  (t (is_pattern? pat (cdr str))) 
;	))

(defun first_atom(L)
	(cond ( (null L) nil)
		  ( (atom (car L)) (car L))
		  (t (listp (car L)) (first_atom (car L)))
	))

;this one works the best
(defun find_all(A L)
	(cond ( (null L) nil)
		  ( (eq (car L) A) (cons (car (cdr L)) (find_all A (cdr L))))
		  ( (listp (car L)) (cons (find_all A (car L)) (find_all A (cdr L))))
		  (t (find_all A (cdr L)))
	))

;(defun find_all(A L)
;	(cond ( (null L) nil)
;		  ( (eq (car L) A)
;			(cond ( (listp (cadr L)) (find_all A (cadr L)))
;				  (t (cons (cadr L) (find_all A (cdr L))))))
;		  (t (find_all A (cdr L)))))

;(defun find_all(A L)
;	(cond ( (null L) nil)
;		  ( (eq A (car L)) 
;		     (cond ( (listp (cadr L)) (find_all A (cadr L)))
;				   ( (atom (cadr L)) (cons (cadr L) (find_all A (cdr L)))))) 
;		  (t (find_all A (cdr L)))
;	))
;(defun find_all(A L)
;	(cond ( (null L) nil)
;		  ( (eq A (car L))
;			(cond ( (listp (cadar L)) (cons (find_all A (cadar L)) (find_all A (cadr L))))
;				  ( (cons (cadar L) (find_all A (cadr L)))))) 
;		  ( (listp (car L)) (find_all A (cadr L)))
;		  (t (find_all A (cdr L)))
;	))

